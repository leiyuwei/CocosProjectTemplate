{"version":3,"sources":["Maybe.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;IAYI,eAAa,CAAW;QAAX,kBAAA,EAAA,QAAW;QAXhB,aAAQ,GAAY,IAAI,CAAC;QACzB,WAAM,GAAM,IAAI,CAAC;QAWrB,IAAI,CAAC,IAAI,IAAI,EAAE;YACX,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;SACnB;aAAM;YACH,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;SACzB;IACL,CAAC;IAfM,UAAI,GAAX,UAAe,CAAI;QACf,OAAO,IAAI,KAAK,CAAI,CAAC,CAAC,CAAC;IAC3B,CAAC;IAEM,aAAO,GAAd;QACI,OAAO,IAAI,KAAK,EAAK,CAAC;IAC1B,CAAC;IAWD,sBAAI,sBAAG;aAAP;YACI,OAAO,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;;;OAAA;IAED,sBAAI,wBAAK;aAAT;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;;;OAAA;IAED,sCAAsC;IACtC,mBAAG,GAAH,UAAO,IAAc;QACjB,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,OAAO,IAAI,KAAK,CAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;SACvC;aAAM;YACH,OAAO,IAAI,KAAK,EAAK,CAAC;SACzB;IACL,CAAC;IAEK,yBAAS,GAAf,UAAmB,IAAuB;;;;;;6BAClC,IAAI,CAAC,KAAK,EAAV,wBAAU;wBACF,qBAAM,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAA;;wBAAxB,CAAC,GAAG,SAAoB;wBAC5B,sBAAO,IAAI,KAAK,CAAI,CAAC,CAAC,EAAC;4BAEvB,sBAAO,IAAI,KAAK,EAAK,EAAC;;;;KAE7B;IAED,oBAAI,GAAJ,UAAK,CAAI;QACL,OAAO,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;IACxB,CAAC;IAED,sCAAsC;IACtC,oBAAI,GAAJ,UAAQ,IAAqB;QACzB,IAAI,IAAI,CAAC,KAAK,EAAE;YACZ,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACzB;aAAM;YACH,OAAO,IAAI,KAAK,EAAK,CAAC;SACzB;IACL,CAAC;IAED,yBAAS,GAAT,UAAW,CAAI;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACrC,CAAC;IAED,qBAAK,GAAL,UAAW,IAAkB,EAAE,EAAY;QACvC,IAAI,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC,KAAK,EAAE;YACxB,OAAO,IAAI,KAAK,CAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;SAC/C;aAAM;YACH,OAAO,IAAI,KAAK,EAAK,CAAC;SACzB;IACL,CAAC;IACL,YAAC;AAAD,CAvEA,AAuEC,IAAA;AAvEY,sBAAK","file":"","sourceRoot":"../../../../../assets/Script/basic","sourcesContent":["import { Fn, Fn2 } from \"./Types\";\n\nexport class Maybe<T> {\n    private _isValid: boolean = null;\n    private _value: T = null;\n\n    static Just<T>(v: T) {\n        return new Maybe<T>(v);\n    }\n\n    static Nothing<T>() {\n        return new Maybe<T>();\n    }\n    \n    constructor (v: T = null) {\n        if (v != null) {\n            this._isValid = true;\n            this._value = v;\n        } else {\n            this._isValid = false;\n        }\n    }\n\n    get val() {\n        return this._value;\n    }\n\n    get valid() {\n        return this._isValid;\n    }\n\n    // Functor f => (a -> b) -> f a -> f b\n    map<U>(func: Fn<T, U>) : Maybe<U> {\n        if (this.valid) {\n            return new Maybe<U>(func(this.val));\n        } else {\n            return new Maybe<U>();\n        }\n    }\n\n    async asyncFmap<U>(func: Fn<T, Promise<U>>) {\n        if (this.valid) {\n            let u = await func(this.val)\n            return new Maybe<U>(u);\n        } else {\n            return new Maybe<U>();\n        }\n    }\n\n    pure(x: T): Maybe<T> {\n        return new Maybe(x);\n    }\n    \n    // Monad m => (a -> m b) -> m a -> m b\n    bind<U>(func: Fn<T, Maybe<U>>) : Maybe<U> {\n        if (this.valid) {\n            return func(this.val);\n        } else {\n            return new Maybe<U>();\n        }\n    }\n    \n    getOrElse (x: T): T {\n        return this.valid ? this.val : x;\n    }\n\n    lift2<U,V>(func: Fn2<T, U, V>, ou: Maybe<U>) : Maybe<V> {\n        if (this.valid && ou.valid) {\n            return new Maybe<V>(func(this.val, ou.val));\n        } else {\n            return new Maybe<V>();\n        }\n    }\n}"]}